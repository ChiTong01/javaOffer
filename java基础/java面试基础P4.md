## java面试基础
- java面试基础4
    + [override](#override)
    + [接口](#接口)
    + [抽象类](#抽象类)
    + [ThreadLocal](#threadlocal)
    + [抽象类和抽象方法的关系](#抽象类和抽象方法的关系)
    + [构造方法规则](#构造方法规则)
#### override
**方法的重写（override）两同两小一大原则：**

 - 方法名相同，参数类型相同
 - 子类返回类型小于等于父类方法返回类型， 
 - 子类抛出异常小于等于父类方法抛出异常，
 - 子类访问权限大于等于父类方法访问权限。
#### 接口
   >1.多实现
   2.变量类型默认且只能为为public static final
   3.函数类型默认且只能为public，只能有public类型的静态成员函数
   4.非静态成员函数没有方法体，静态成员函数有方法体
   5.子类必须实现所有接口函数
   6.可以有main方法；可以new一个接口，需要在方法体中实现所有接口函数
   7.没有构造器
#### 抽象类
1.单继承  
2.变量类型不限（静态变量+非静态变量）  
3.函数类型不限（静态函数+非静态函数）  
4.非静态函数包含没有方法体的抽象函数. 有方法体的普通函数  
5.子类可以不覆写父类的抽象方法，但子类也要申明为抽象类；子类可以选择覆写父类的非抽象方法  
6.可以有main方法；不可以new一个抽象类  
7.可以有构造器  
#### ThreadLocal
 `ThreadLocal`可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。ThreadLocal ==不是用于解决共享变量的问题== 的，不是为了协调线程同步而存在，而是为了==方便每个线程处理自己的状态==而引入的一个机制.
 #### 抽象类和抽象方法的关系
 1）抽象类可以包括抽象方法和非抽象方法  
2）如果类里面有抽象方法的话，那么类一定要声明为抽象的！
#### 构造方法规则
`识别合法`的构造方法；
 1，构造方法可以被重载，一个构造方法可以通过this关键字调用另一个构造方法，this语句必须位于构造方法的第一行；
       重载：方法的重载(overload)：重载构成的条件：方法的名称相同，但参数类型或参数个数不同，才能构成方法的重载。   
        2 ，当一个类中没有定义任何构造方法，Java将自动提供一个缺省构造方法；   
        3， 子类通过super关键字调用父类的一个构造方法；   
        4，当子类的某个构造方法没有通过super关键字调用父类的构造方法，通过这个构造方法创建子类对象时，会自动先调用父类的缺省构造方法   
        5，构造方法不能被`static`、`final`、`synchronized`、`abstract`、`native`修饰，但可以被public、private、protected修饰；
   6， 构造方法不是类的成员方法；  
    7， 构造方法不能被继承。
    
